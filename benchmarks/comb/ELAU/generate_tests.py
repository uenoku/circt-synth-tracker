#!/usr/bin/env python3
"""
Test generator for ELAU benchmarks.

This script automatically generates lit test files for ELAU arithmetic modules.
Each test follows this pipeline:
  1. circt-verilog: Parse SystemVerilog to MLIR with parameters
  2. firtool: Convert MLIR to synthesizable Verilog
  3. SYNTH_TOOL: Synthesize to AIG format
  4. judge + submit: Evaluate and record results

Usage:
    ./generate_tests.py

The script reads the test definitions from the `tests` list at the bottom
and generates corresponding .test files in the tests/ directory.
"""

from pathlib import Path


def generate_test(test_cases):
    """
    Generate test cases for ELAU benchmarks.

    Args:
        test_cases: List of tuples (file_name, top_module, params)
            - file_name: SystemVerilog file name (without .sv extension)
            - top_module: Name of the top module to synthesize
            - params: List of parameter names to pass as -G name=%BW
    """
    for file_name, top_module, params in test_cases:
        # Build parameter string: "-G param1=%BW -G param2=%BW ..."
        param_str = " ".join(f"-G {p}=%BW" for p in params)

        # Generate test file content with RUN directives
        test = f"""
// Auto-generated by generate_tests.py -- do not edit manually
// Re-run ./generate_tests.py to update this file.
RUN: circt-verilog %ELAU_SRC/arith_utils.sv  %ELAU_SRC/{file_name}.sv  --libdir %ELAU_SRC/ -top {top_module} {param_str} -o %t.sv.mlir
RUN: circt-opt -export-verilog %t.sv.mlir -o /dev/null > %t.sv
// Note: BW is not passed here since the generated verilog already has the parameter instantiated
RUN: %SYNTH_TOOL %t.sv -top {top_module} -o %t.aig
RUN: %judge %t.aig | %submit %s --name {top_module}
        """

        # Write to tests/{file_name}.test
        test_file = f"tests/{file_name}.test"
        path = Path(__file__).parent / test_file
        with open(path, "w") as f:
            f.write(test.strip() + "\n")
        print(f"Generated test file: {test_file}")


if __name__ == "__main__":
    # Test definitions: (file_name, top_module, parameter_list)
    # Add new tests here following the same pattern
    tests = [
        ("AbsVal", "behavioural_AbsVal", ["width"]),
        ("Add", "behavioural_Add", ["width"]),
        ("AddC", "behavioural_AddC", ["width"]),
        ("AddCfast", "behavioural_AddCfast", ["width"]),
        ("AddCsv", "behavioural_AddCsv", ["width"]),
        ("AddMod2Nm1", "behavioural_AddMod2Nm1", ["width"]),
        ("AddMod2Nm1s0", "behavioural_AddMod2Nm1s0", ["width"]),
        ("AddMop", "behavioural_AddMop", ["width"]),
        # FIXME: emap fails for some reason
        # ("AddMod2Np1", "behavioural_AddMod2Np1", ["width"]),
        # ("AddMulSgn", "behavioural_AddMulSgn", ["widthX", "widthY"]),
        ("AddMulUns", "behavioural_AddMulUns", ["widthX", "widthY"]),
        ("AddSub", "behavioural_AddSub", ["width"]),
        ("AddSubC", "behavioural_AddSubC", ["width"]),
        ("AddSubV", "behavioural_AddSubV", ["width"]),
        ("AddV", "behavioural_AddV", ["width"]),
        ("AllOneDet", "behavioural_AllOneDet", ["width"]),
        ("AllZeroDet", "behavioural_AllZeroDet", ["width"]),
        ("Bin2Gray", "behavioural_Bin2Gray", ["width"]),
        ("CmpEQ", "behavioural_CmpEQ", ["width"]),
        ("CmpEQGE", "behavioural_CmpEQGE", ["width"]),
        ("CmpGE", "behavioural_CmpGE", ["width"]),
        ("Cnt", "behavioural_Cnt", ["width"]),
        ("Dec", "behavioural_Dec", ["width"]),
        ("DecC", "behavioural_DecC", ["width"]),
        ("Decode", "behavioural_Decode", ["width"]),
        # FIXME: Div cannot be lowered yet
        # ("DivArrSgn", "behavioural_DivArrSgn", ["widthX", "widthY"]),
        # ("DivArrUns", "behavioural_DivArrUns", ["widthX", "widthY"]),
        # FIXME: LLHD remaining
        # ("Encode", "behavioural_Encode", ["width"]),
        ("FullAdder", "behavioural_FullAdder", []),
        ("Gray2Bin", "behavioural_Gray2Bin", ["width"]),
        ("Inc", "behavioural_Inc", ["width"]),
        ("IncC", "behavioural_IncC", ["width"]),
        ("IncDec", "behavioural_IncDec", ["width"]),
        ("IncDecC", "behavioural_IncDecC", ["width"]),
        # FIXME: LLHD remaining
        # ("IncGray", "behavioural_IncGray", ["width"]),
        # ("IncGrayC", "behavioural_IncGrayC", ["width"]),
        ("LeadOneDet", "behavioural_LeadOneDet", ["width"]),
        ("LeadSignDet", "behavioural_LeadSignDet", ["width"]),
        ("LeadZeroDet", "behavioural_LeadZeroDet", ["width"]),
        ("Log2", "behavioural_Log2", ["width"]),
        ("MulAddSgn", "behavioural_MulAddSgn", ["widthX", "widthY", "widthA"]),
        ("MulAddUns", "behavioural_MulAddUns", ["widthX", "widthY", "widthA"]),
        ("MulSgn", "behavioural_MulSgn", ["widthX", "widthY"]),
        ("MulUns", "behavioural_MulUns", ["widthX", "widthY"]),
        ("Neg", "behavioural_Neg", ["width"]),
        ("NegC", "behavioural_NegC", ["width"]),
        ("RedAnd", "behavioural_RedAnd", ["width"]),
        ("RedOr", "behavioural_RedOr", ["width"]),
        ("RedXor", "behavioural_RedXor", ["width"]),
        # FIXME: Support math.powi lowering
        # ("SqrSgn", "behavioural_SqrSgn", ["width"]),
        # ("SqrtArrUns", "behavioural_SqrtArrUns", ["widthX"]),
        # ("SqrUns", "behavioural_SqrUns", ["width"]),
        ("Sub", "behavioural_Sub", ["width"]),
        ("SubC", "behavioural_SubC", ["width"]),
        ("SubCZ", "behavioural_SubCZ", ["width"]),
        ("SubV", "behavioural_SubV", ["width"]),
        ("SubVZ", "behavioural_SubVZ", ["width"]),
        ("SumZeroDet", "behavioural_SumZeroDet", ["width"]),
    ]

    generate_test(tests)
